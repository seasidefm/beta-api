generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["linux-arm64-openssl-1.1.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// Ongoing playlist
// =========================
// - The playlist table is sort of a ledger, tracking every single
//   song that has played
// - Not immutable, as duplicates will be removed
// - New songs and artists are added as a "playlist entry"
//   and created if missing, then logged no matter what

model PlaylistEntry {
  id        Int      @id @default(autoincrement())
  played_on DateTime @default(now())
  playing   Boolean  @default(false)
  song_id   Int
  song      Song     @relation(fields: [song_id], references: [id], onDelete: Cascade, onUpdate: Restrict, map: "fk_playlist_song")

  @@index([playing, song_id], map: "current_song")
}

model Artist {
  id      Int     @id @default(autoincrement())
  name    String  @unique @db.VarChar(100)
  aliases String? @db.VarChar(256)
  songs   Song[]

  @@index([name, aliases], map: "artist")
}

model Song {
  id         Int        @id @default(autoincrement())
  song_title String
  artist_id  Int
  artists    Artist     @relation(fields: [artist_id], references: [id], onDelete: Cascade, onUpdate: Restrict, map: "fk_song_artist")
  favorites  Favorite[]

  PlaylistEntry PlaylistEntry[]
  @@unique([song_title, artist_id])
  @@index([artist_id], map: "fk_song_artist")
}

// Profile
// =========================
// - User object is basic, as data mostly comes from OAuth provider
// - All favorites, requests, and future user objects
//   will use the user object in a one-to-many relationship
// - Favorites tie songs to users in a many-to-many relationship
// - Requests are ONLY connected to a user. I will not assume
//   that a user in the twitch chat has proper data formatting
//   to attempt to tie it automatically to an artist/song
// - This was made in response to the old way, where all
//   tables were duplicates and completely unoptimized

model User {
  id                Int                 @id @default(autoincrement())
  name              String              @unique(map: "name") @db.VarChar(45)
  favorites         Favorite[]
  userLevel         UserExperience?
  Request           Request[]
  // Optional because users are generated BEFORE twitch login
  twitch            TwitchUserProfile?
  TwitchCredentials TwitchCredentials[]
}

// Twitch Profile
// =========================

model TwitchUserProfile {
  user              Int
  twitch_id         String
  login             String
  display_name      String
  type              String
  broadcaster_type  String
  description       String
  profile_image_url String
  offline_image_url String
  view_count        Int
  created_at        String

  TwitchCredentials TwitchCredentials[]
  OnPlatformUser    User                @relation(fields: [user], references: [id], onDelete: Cascade, onUpdate: Restrict)

  @@unique([user])
  @@unique([twitch_id])
}

model TwitchCredentials {
  id             Int      @id @default(autoincrement())

  // Reference various user logins
  // THESE MUST NOT BE UNIQUE
  twitch_id      String
  user_id        Int

  platform_token String
  date_created   DateTime @default(now())
  last_used      DateTime @default(now())

  // These are directly issued by twitch
  access_token  String
  refresh_token String
  scope         String?
  token_type    String  @default("bearer")

  TwitchUserProfile TwitchUserProfile @relation(fields: [twitch_id], references: [twitch_id])
  OnPlatformUser    User              @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: Restrict)


  @@unique([platform_token])
}

// Platform Data
// =========================

model Favorite {
  song      Int
  user      Int
  dateSaved DateTime @default(now())
  songData  Song     @relation(fields: [song], references: [id], onDelete: Cascade, onUpdate: Restrict, map: "fk_song")
  userData  User     @relation(fields: [user], references: [id], onDelete: Cascade, onUpdate: Restrict, map: "fk_user")

  @@unique([song, user], map: "song")
  @@index([user], map: "fk_user")
  @@index([song, user], map: "user_songs")
}

model Request {
  id            Int       @id @default(autoincrement())
  song          String
  artist        String
  dateRequested DateTime  @default(now())
  datePlayed    DateTime?

  user                 Int
  userData             User        @relation(fields: [user], references: [id], onDelete: Cascade, onUpdate: Restrict, map: "fk_user_request")
  meta                 RequestMeta @relation(fields: [requestMetaRequestId], references: [requestId], onDelete: Cascade, onUpdate: Restrict)
  requestMetaRequestId Int
}

model RequestMeta {
  requestId   Int       @id @default(autoincrement())
  ripped      Boolean   @default(false)
  streamed    Boolean   @default(false)
  ownedStatus Boolean   @default(false)
  notes       String?
  Request     Request[]
}

// Seaside RPG
// =========================

model ExperienceLevel {
  id           Int    @id @default(autoincrement())
  level        Int
  name         String
  required_exp Int

  UserExperience UserExperience[]
  @@unique([level])
  @@unique([name])
  @@unique([required_exp])
}

model UserExperience {
  user             User            @relation(fields: [userId], references: [id])
  userId           Int
  level            Int             @default(0)
  experienceLevel  ExperienceLevel @relation(fields: [level], references: [level])
  total_experience Int

  @@unique([userId])
}

// API - Machine Access
// =========================

model MachineUser {
  name         String
  clientId     String @id
  clientSecret String

  @@unique([name])
}
